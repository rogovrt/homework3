1) Пары и кортежи удобны, если функции возвращается несколько значений различных типов.
2) std::array удобен для работы с последовательностью из фиксированного числа элементов, так как память выделяется на стеке, что ускоряет работу, нет дополнительных выделений памяти и существует прямой доступ к элементам по индексу.
3) std::vector - абстрация над динамическим массивом, обеспечивающая доступ к элементу за константное время. Высокопроизводительны при вставке и удалениив конце. Любой алгоритм STL может использовать итераторы на вектор (так как они произвольного доступа), что удобно. Итог: если нужен динамический массив со вставкой преимущественно в конец- используй вектор.
4) std::deque - также абстракция над динамическим массивом. Высопроизводительна при вставке и в начало, и в конец; имеет итераторы произвольного доступа; лучше не ссылаться на элементы (в силу страничной реализации).
5) std::list - абстрация над двусвязным списком. Не предоставляет доступ произвольный доступ (проходы по цепочке); вставка и удаление за константное время из любой части контейнера; все итераторы, указатели, ссылки остаются валдиными после удаления элемента; итераторы двунаправленные.
6) std::forward_list - абстракция над односвязным списком. Не предоставяляет произвольный доступ к элементам (проход по цепочке, однонаправленный итератор); вставка и удаление за константное время из любой части контейнера (т.к. не надо переприсваивать значения остальных элементов, достаточно просто "перекинуть" соседние указатели); все итераторы, указатели и ссылки остаются валидными после удаления элемента; много специальных функция-членов для перемещения и удаления элементов.
7) Адаптеры контейнеров: stack (LIFO) - последний вошел, первый вышел; queue (FIFO) - первый вошел, первый вышел; priority_queue (FIFO + sort) - как очередь, только дополнительно сортирует элементы.
8) Циклический буффер удобен, если стремимся ограничить количество используемой памяти, чтобы контейнер не разростался, или если идет непрерывный потом данных, причем старые данные не нужны, а следовательно будут затираться.
9) Элемент, который добавлен позже по времени может стоять в памяти левее, чем более ранний, что противоречит концепции стандартной библиотеки.
10) Неудачные: классический двумерный массив, вектор векторов. Более удачные: std::valarray представим как многомерный массив, Boost.Multiarray.
